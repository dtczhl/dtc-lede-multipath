Index: linux-4.9.44/net/Makefile
===================================================================
--- linux-4.9.44.orig/net/Makefile
+++ linux-4.9.44/net/Makefile
@@ -11,6 +11,8 @@ tmp-$(CONFIG_COMPAT) 		:= compat.o
 obj-$(CONFIG_NET)		+= $(tmp-y)
 
 # LLC has to be linked before the files in net/802/
+# ------ dtc -------------
+obj-y					+= dtc/
 obj-$(CONFIG_LLC)		+= llc/
 obj-$(CONFIG_NET)		+= ethernet/ 802/ sched/ netlink/
 obj-$(CONFIG_NETFILTER)		+= netfilter/
Index: linux-4.9.44/net/dtc/Makefile
===================================================================
--- /dev/null
+++ linux-4.9.44/net/dtc/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += dtc_debugfs.o
Index: linux-4.9.44/net/dtc/dtc_debugfs.c
===================================================================
--- /dev/null
+++ linux-4.9.44/net/dtc/dtc_debugfs.c
@@ -0,0 +1,264 @@
+#include "dtc_debugfs.h"
+
+/* main directory */
+static struct dentry *main_dir;
+static u8 nBuffer = 0;
+
+/* enable */
+static struct dentry *file_enable;
+u32 dtc_debugfs_enable = 0;
+
+/* timestamp */
+static struct dentry *file_time_loc;
+u32 dtc_debugfs_time_loc = 0;
+static struct timeval timestamp;
+static struct timeval timestamp2;
+
+/* target */
+static struct dentry *file_target;
+static char target_ip_port[24] = "1.1.1.1 1\n";
+u32 dtc_debugfs_target_ip = 0;
+u16 dtc_debugfs_target_port = 0;
+
+/* info */
+static struct dentry *file_info;
+#define INFO_BUF_SIZE   33
+static u8 info_buf[INFO_BUF_SIZE];
+
+/* log1 */
+static struct dentry *file_log1;
+static const u64 log1_buf_size = 40 * 1024 * 1024;
+static u64 log1_buf_pos = 0;
+static struct debugfs_blob_wrapper log1_blob;
+
+/* log2 */
+static struct dentry *file_log2;
+static const u64 log2_buf_size = 40 * 1024 * 1024;
+static u64 log2_buf_pos = 0;
+static struct debugfs_blob_wrapper log2_blob;
+
+/* -------- implementation -------- */
+
+/* ---- info ---- */
+static ssize_t info_read_file(struct file *file, char __user *user_buf,
+        size_t count, loff_t *ppos){
+    int buf_len = snprintf(info_buf, INFO_BUF_SIZE,
+            "HZ: %-4d\n"
+            "int: %-1d\n"
+            "char: %-1d\n"
+            "long: %-1d\n"
+            , HZ, (int)sizeof(int), (int)sizeof(char), (int)sizeof(long));
+    return simple_read_from_buffer(user_buf, count, ppos, info_buf, buf_len);
+}
+static struct file_operations info_fops = {
+    .read = info_read_file,
+};
+
+/* ---- target ---- */
+static ssize_t target_read_file(struct file *file, char __user *user_buf,
+        size_t count, loff_t *ppos){
+    return simple_read_from_buffer(user_buf, count, ppos, 
+            target_ip_port, strlen(target_ip_port));
+}
+static ssize_t target_write_file(struct file *file, const char __user *user_buf,
+        size_t count, loff_t *ppos){
+    int i = 0;
+    int substr_index = 0;
+    int sub_ip = 0;
+    u32 ip_temp = 0;
+    u16 port_temp = 0;
+    
+    if (count >= sizeof(target_ip_port)) // length error
+        return -EINVAL;
+    if (simple_write_to_buffer(target_ip_port, sizeof(target_ip_port), 
+                ppos, user_buf, count) != count)
+        return -EINVAL;
+
+    for (i = 0; i < count; i++){
+        if (target_ip_port[i] >= '0' && target_ip_port[i] <= '9'){ // number
+            if (substr_index == 0){
+                sub_ip = 10*sub_ip + (target_ip_port[i]-'0');
+            } else if (substr_index == 1){
+                port_temp = 10*port_temp + (target_ip_port[i]-'0');
+            }
+        } else if (target_ip_port[i] == '.'){ // delimiter in ip
+            ip_temp = (ip_temp << 8) + sub_ip;
+            sub_ip = 0;
+        } else if (target_ip_port[i] == ' '){ // delimiter between ip and port
+            ip_temp = (ip_temp << 8) + sub_ip;
+            sub_ip = 0;
+            substr_index++;
+        }
+    }
+    
+    dtc_debugfs_target_ip = htonl(ip_temp);
+    dtc_debugfs_target_port = htons(port_temp);
+    
+    /* rewind to buffer beginning */
+    if (nBuffer >= 1){
+        log1_buf_pos = 0;
+        log1_blob.size = 0;
+    }
+    if (nBuffer >= 2){
+        log2_buf_pos = 0;
+        log2_blob.size = 0;
+    }
+    
+    return count;
+}
+static struct file_operations target_fops = {
+    .read = target_read_file,
+    .write = target_write_file,
+};
+
+
+
+
+/* initialization */
+int dtc_init_debugfs(char *dirname, int buffer_num){
+    /* main directory */
+    main_dir = debugfs_create_dir(dirname, 0);
+    if (!main_dir){
+        printk(KERN_ALERT "dtc: main dir failed!\n");
+        return -1;
+    }
+    /* enable */
+    file_enable = debugfs_create_u32("enable", 0666, main_dir, 
+            &dtc_debugfs_enable);
+    if (!file_enable){
+        printk(KERN_ALERT "dtc: enable file failed!\n");
+        return -1;
+    }
+    /* timestamp */
+    file_time_loc = debugfs_create_u32("timeLoc", 0666, main_dir,
+            &dtc_debugfs_time_loc);
+    if (!file_time_loc){
+        printk(KERN_ALERT "dtc: timeLoc file failed!\n");
+        return -1;
+    }
+    /* target */
+    file_target = debugfs_create_file("target", 0666, main_dir, NULL,
+            &target_fops);
+    if (!file_target){
+        printk(KERN_ALERT "dtc: target file failed!\n");
+        return -1;
+    }
+    /* info */
+    file_info = debugfs_create_file("info", 04444, main_dir, NULL,
+            &info_fops);
+    if (!file_info){
+        printk(KERN_ALERT "dtc: info file failed!\n");
+        return -1;
+    }
+    nBuffer = buffer_num;
+    if (nBuffer == 0) return 0;
+    /* log1 */
+    log1_blob.data = vmalloc(log1_buf_size);
+    log1_blob.size = 0;
+    file_log1 = debugfs_create_blob("log1", 0444, main_dir,
+            &log1_blob);
+    if (!file_log1){
+        printk(KERN_ALERT "dtc: log1 file failed!\n");
+        return -1;
+    }
+    if (nBuffer == 1) return 0;
+    /* log2 */
+    log2_blob.data = vmalloc(log2_buf_size);
+    log2_blob.size = 0;
+    file_log2 = debugfs_create_blob("log2", 0444, main_dir,
+            &log2_blob);
+    if (!file_log2){
+        printk(KERN_ALERT "dtc: log2 file failed!\n");
+        return -1;
+    }
+    if (nBuffer == 2) return 0;
+
+    return 0;
+}
+
+/* destructor */
+void dtc_cleanup_debugfs(void){
+    debugfs_remove_recursive(main_dir);
+    return;
+}
+
+/* timestamp -> log1 */    
+#define TIME_MSG_SIZE    (DTC_DEC_32 + 1 + DTC_DEC_64 + 1 + DTC_DEC_64 + 2 )
+static u8 time_msg[TIME_MSG_SIZE];
+static u32 time_msg_len = 0; 
+void dtc_log_time(u32 time_loc){
+    // time_loc time_sec time_usec
+   
+    if (log1_buf_pos + TIME_MSG_SIZE >= log1_buf_size) return;
+
+    do_gettimeofday(&timestamp);
+    time_msg_len = snprintf(time_msg, TIME_MSG_SIZE, "%u %lu %lu\n",
+            time_loc, timestamp.tv_sec, timestamp.tv_usec);
+    memcpy((char*)log1_blob.data+log1_buf_pos, time_msg, time_msg_len);
+    
+    log1_buf_pos += time_msg_len;
+    log1_blob.size = log1_buf_pos;
+    return;
+}
+// append data
+#define U32_MSG_SIZE    ( DTC_DEC_32 + 2 )
+static u8 u32_msg[U32_MSG_SIZE];
+static u32 u32_msg_len; 
+void dtc_log_time_u32(u32 data){
+   if (log1_buf_pos + U32_MSG_SIZE >= log1_buf_size) return;
+    u32_msg_len = snprintf(u32_msg, U32_MSG_SIZE, "%u\n",
+            ntohl(data));
+    memcpy((char*)log1_blob.data+log1_buf_pos, u32_msg, u32_msg_len);
+
+    log1_buf_pos += u32_msg_len;
+    log1_blob.size = log1_buf_pos;
+    return;
+}
+// append data
+#define INT_MSG_SIZE    ( DTC_DEC_32 + 2 )
+static u8 int_msg[INT_MSG_SIZE];
+static u32 int_msg_len;
+void dtc_log_buffer_size(int data){
+    if (log1_buf_pos + INT_MSG_SIZE >= log1_buf_size) return;
+    int_msg_len = snprintf(int_msg, INT_MSG_SIZE, "%u\n",
+            data);
+    memcpy((char*)log1_blob.data+log1_buf_pos, int_msg, int_msg_len);
+
+    log1_buf_pos += int_msg_len;
+    log1_blob.size = log1_buf_pos;
+    return;
+}
+
+/* timestamp -> log2 */    
+#define TIME_MSG2_SIZE    (DTC_DEC_32 + 1 + DTC_DEC_64 + 1 + DTC_DEC_64 + 2 )
+static u8 time_msg2[TIME_MSG2_SIZE];
+static u32 time_msg2_len = 0; 
+void dtc_log2_time(u32 time_loc){
+    // time_loc time_sec time_usec
+   
+    if (log2_buf_pos + TIME_MSG2_SIZE >= log2_buf_size) return;
+
+    do_gettimeofday(&timestamp2);
+    time_msg2_len = snprintf(time_msg2, TIME_MSG2_SIZE, "%u %lu %lu\n",
+            time_loc, timestamp2.tv_sec, timestamp2.tv_usec);
+    memcpy((char*)log2_blob.data+log2_buf_pos, time_msg2, time_msg2_len);
+    
+    log2_buf_pos += time_msg2_len;
+    log2_blob.size = log2_buf_pos;
+    return;
+}
+// append data
+#define U32_MSG2_SIZE    ( DTC_DEC_32 + 2 )
+static u8 u32_msg2[U32_MSG2_SIZE];
+static u32 u32_msg2_len; 
+void dtc_log2_time_u32(u32 data){
+   if (log2_buf_pos + U32_MSG2_SIZE >= log2_buf_size) return;
+    u32_msg2_len = snprintf(u32_msg2, U32_MSG2_SIZE, "%u\n",
+            ntohl(data));
+    memcpy((char*)log2_blob.data+log2_buf_pos, u32_msg2, u32_msg2_len);
+
+    log2_buf_pos += u32_msg2_len;
+    log2_blob.size = log2_buf_pos;
+    return;
+}
+
Index: linux-4.9.44/net/dtc/dtc_debugfs.h
===================================================================
--- /dev/null
+++ linux-4.9.44/net/dtc/dtc_debugfs.h
@@ -0,0 +1,66 @@
+#ifndef _DTC_DEBUGFS_H_
+#define _DTC_DEBUGFS_H_
+
+#include <linux/debugfs.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/ip.h>
+#include <linux/string.h>
+#include <linux/timekeeping.h>
+#include <linux/ieee80211.h>
+
+/* protocol */
+#define DTC_TCP  ( 1 << 0 )
+#define DTC_UDP  ( 1 << 1 )
+
+/* timekeeping location */
+#define DTC_TIME_SOCK   ( 1 << 0 )
+#define DTC_TIME_TCP    ( 1 << 1 )
+#define DTC_TIME_UDP    ( 1 << 2 )
+#define DTC_TIME_MAC    ( 1 << 3 )
+#define DTC_TIME_ATH    ( 1 << 4 )
+
+/* byte size for APU2 */
+#define DTC_CHAR_SIZE   1
+#define DTC_INT_SIZE    4
+#define DTC_LONG_SIZE   8
+
+/* length: decimals to string literals */
+#define DTC_DEC_32  10
+#define DTC_DEC_64  20
+
+/* variables */
+extern u32 dtc_debugfs_enable;
+extern u32 dtc_debugfs_time_loc; 
+extern u32 dtc_debugfs_target_ip;
+extern u16 dtc_debugfs_target_port;
+
+/* functions */
+int dtc_init_debugfs(char *dirname, int buff_num);
+void dtc_cleanup_debugfs(void);
+// log 1
+void dtc_log_time(u32 time_loc);
+void dtc_log_time_u32(u32 data);
+void dtc_log_buffer_size(int buffersize);
+// log 2
+void dtc_log2_time(u32 time_loc);
+void dtc_log2_time_u32(u32 data);
+
+/* inline functions */
+// point to udp data payload
+static inline unsigned char *dtc_skb_udp_payload(const struct sk_buff *skb){
+    return skb_transport_header(skb) + 8;
+}
+// ieee80211 data frame
+static inline int dtc_is_ieee80211_data(const struct sk_buff *skb, const __le16 frame_control){
+// udp + ip + ieee80211
+#define MIN_FRAME ( 8 + 20 + 10 )
+    if (skb->data_len < MIN_FRAME ) return 0;
+    return (frame_control & 0x000F) == IEEE80211_FTYPE_DATA;
+}
+
+
+#endif
Index: linux-4.9.44/net/socket.c
===================================================================
--- linux-4.9.44.orig/net/socket.c
+++ linux-4.9.44/net/socket.c
@@ -108,6 +108,9 @@
 #include <net/busy_poll.h>
 #include <linux/errqueue.h>
 
+// ----------- dtc -------------
+#include "dtc/dtc_debugfs.h"
+
 #ifdef CONFIG_NET_RX_BUSY_POLL
 unsigned int sysctl_net_busy_read __read_mostly;
 unsigned int sysctl_net_busy_poll __read_mostly;
@@ -826,6 +829,15 @@ static ssize_t sock_write_iter(struct ki
 	if (sock->type == SOCK_SEQPACKET)
 		msg.msg_flags |= MSG_EOR;
 
+    // ----------- dtc ----------------
+    /*
+    if (dtc_debugfs_enable & DTC_IP_PROTO_MASK_UDP &&
+            dtc_debugfs_time_loc & DTC_TIME_SOCK_WRITE_ITER){
+        // udp
+        dtc_log_micro_time(DTC_TIME_SOCK_WRITE_ITER);
+    }
+    */
+
 	res = sock_sendmsg(sock, &msg);
 	*from = msg.msg_iter;
 	return res;
@@ -2505,6 +2517,9 @@ static int __init sock_init(void)
 	if (err)
 		goto out;
 
+    // ----- dtc -----
+    dtc_init_debugfs("dtc_init", 1);
+
 	/*
 	 *      Initialize skbuff SLAB cache
 	 */
Index: linux-4.9.44/net/ipv4/udp.c
===================================================================
--- linux-4.9.44.orig/net/ipv4/udp.c
+++ linux-4.9.44/net/ipv4/udp.c
@@ -116,6 +116,9 @@
 #include <net/sock_reuseport.h>
 #include <net/addrconf.h>
 
+// -------- dtc ------------
+#include "../dtc/dtc_debugfs.h"
+
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
 
@@ -952,6 +955,14 @@ int udp_sendmsg(struct sock *sk, struct
 		connected = 1;
 	}
 
+    // ----- dtc --------
+    if (dtc_debugfs_enable & DTC_UDP &&
+            dtc_debugfs_time_loc & DTC_TIME_UDP &&
+            dtc_debugfs_target_ip == daddr &&
+            dtc_debugfs_target_port == dport){    
+        dtc_log_time(DTC_TIME_UDP);
+    }
+
 	ipc.sockc.tsflags = sk->sk_tsflags;
 	ipc.addr = inet->inet_saddr;
 	ipc.oif = sk->sk_bound_dev_if;
@@ -1052,9 +1063,20 @@ back_from_confirm:
 		skb = ip_make_skb(sk, fl4, getfrag, msg, ulen,
 				  sizeof(struct udphdr), &ipc, &rt,
 				  msg->msg_flags);
-		err = PTR_ERR(skb);
-		if (!IS_ERR_OR_NULL(skb))
+		err = PTR_ERR(skb); 
+		if (!IS_ERR_OR_NULL(skb)){
 			err = udp_send_skb(skb, fl4);
+            
+            // ----- dtc --------
+            if (dtc_debugfs_enable & DTC_UDP &&
+                    dtc_debugfs_time_loc & DTC_TIME_UDP &&
+                    dtc_debugfs_target_ip == daddr &&
+                    dtc_debugfs_target_port == dport){    
+                // dtc_log_time_u32( *((u32 *)(skb_transport_header(skb) + 8)) ); // udp header
+                dtc_log_time_u32( *((u32 *)dtc_skb_udp_payload(skb))  );
+            }
+
+        }
 		goto out;
 	}
 
@@ -1763,6 +1785,23 @@ int __udp4_lib_rcv(struct sk_buff *skb,
 	if (udp4_csum_init(skb, uh, proto))
 		goto csum_error;
 
+    // ------------ dtc -------------
+    if (dtc_debugfs_enable & DTC_UDP &&
+            dtc_debugfs_time_loc & DTC_TIME_UDP &&
+            ( 
+               (
+                dtc_debugfs_target_ip == daddr &&
+                dtc_debugfs_target_port == uh->dest 
+               ) || (
+                dtc_debugfs_target_ip == saddr &&
+                dtc_debugfs_target_port == uh->source    
+               )
+            )
+            ){
+        dtc_log_time(0x0F0000 + DTC_TIME_UDP);
+        dtc_log_time_u32( *(u32 *)dtc_skb_udp_payload(skb) );
+    }
+
 	sk = skb_steal_sock(skb);
 	if (sk) {
 		struct dst_entry *dst = skb_dst(skb);
